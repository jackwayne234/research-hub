<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Benford's Law Through a Black Hole — Causal Set Model</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Inter:wght@300;400;600&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a1a;
    color: #c8cad0;
    font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
    overflow-x: hidden;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #horizon-flash {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 1000;
    border: 0px solid transparent;
    transition: none;
  }
  #horizon-flash.active {
    animation: horizonPulse 1.8s ease-out forwards;
  }
  @keyframes horizonPulse {
    0%   { border-width: 0px; border-color: rgba(255, 80, 40, 0); background: rgba(255, 60, 20, 0.15); }
    10%  { border-width: 8px; border-color: rgba(255, 80, 40, 0.9); background: rgba(255, 60, 20, 0.12); }
    30%  { border-width: 5px; border-color: rgba(255, 60, 20, 0.6); background: rgba(255, 60, 20, 0.05); }
    60%  { border-width: 3px; border-color: rgba(255, 40, 10, 0.3); background: rgba(255, 60, 20, 0.01); }
    100% { border-width: 0px; border-color: rgba(255, 40, 10, 0); background: rgba(255, 60, 20, 0); }
  }

  #floor-flash {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 999;
    border: 0px solid transparent;
  }
  #floor-flash.active {
    animation: floorPulse 2.2s ease-out forwards;
  }
  @keyframes floorPulse {
    0%   { border-width: 0px; border-color: rgba(0, 180, 255, 0); background: rgba(0, 140, 255, 0.12); }
    10%  { border-width: 6px; border-color: rgba(0, 180, 255, 0.8); background: rgba(0, 140, 255, 0.08); }
    40%  { border-width: 3px; border-color: rgba(0, 160, 255, 0.4); background: rgba(0, 140, 255, 0.03); }
    100% { border-width: 0px; border-color: rgba(0, 160, 255, 0); background: rgba(0, 140, 255, 0); }
  }

  .container {
    width: 100%;
    max-width: 1100px;
    padding: 20px 24px;
    position: relative;
    z-index: 1;
  }

  h1 {
    font-family: 'JetBrains Mono', monospace;
    font-weight: 300;
    font-size: 1.35rem;
    text-align: center;
    margin: 18px 0 6px 0;
    letter-spacing: 0.08em;
    color: #e0e2e8;
  }
  h1 span.accent { color: #ff6a3a; font-weight: 500; }
  h1 span.dim { color: #6a6d78; }

  .subtitle {
    text-align: center;
    font-size: 0.78rem;
    color: #5a5d68;
    font-family: 'JetBrains Mono', monospace;
    margin-bottom: 18px;
    letter-spacing: 0.04em;
  }

  /* HUD Panel */
  .hud-row {
    display: flex;
    gap: 12px;
    margin-bottom: 14px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .hud-card {
    background: rgba(18, 18, 36, 0.85);
    border: 1px solid rgba(60, 64, 80, 0.4);
    border-radius: 8px;
    padding: 10px 16px;
    min-width: 130px;
    text-align: center;
    backdrop-filter: blur(4px);
    transition: border-color 0.4s;
  }
  .hud-card.highlight-horizon { border-color: rgba(255, 80, 40, 0.7); }
  .hud-card.highlight-floor   { border-color: rgba(0, 170, 255, 0.7); }

  .hud-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.62rem;
    color: #6a6d78;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    margin-bottom: 4px;
  }
  .hud-value {
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.1rem;
    font-weight: 500;
    color: #e8eaf0;
    line-height: 1.2;
  }
  .hud-value.zone-outside { color: #4ade80; }
  .hud-value.zone-horizon { color: #ff6a3a; }
  .hud-value.zone-inside  { color: #f87171; }
  .hud-value.zone-floor   { color: #38bdf8; }

  .hud-value.verdict-conforms { color: #4ade80; }
  .hud-value.verdict-marginal { color: #fbbf24; }

  /* Delta meter */
  .delta-meter {
    width: 100%;
    height: 4px;
    background: rgba(40, 40, 60, 0.6);
    border-radius: 2px;
    margin-top: 6px;
    overflow: hidden;
  }
  .delta-meter-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.15s, background 0.15s;
  }

  /* Canvas area */
  .canvas-wrap {
    position: relative;
    width: 100%;
    margin-bottom: 12px;
    background: rgba(12, 12, 28, 0.6);
    border: 1px solid rgba(50, 54, 70, 0.35);
    border-radius: 10px;
    overflow: hidden;
  }
  canvas#starfield { display: block; }
  .canvas-wrap canvas { display: block; max-width: 100%; height: auto; }

  /* Controls */
  .controls-row {
    display: flex;
    align-items: center;
    gap: 14px;
    margin-bottom: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    padding: 7px 18px;
    border: 1px solid rgba(80, 84, 100, 0.5);
    border-radius: 6px;
    background: rgba(24, 24, 44, 0.8);
    color: #c8cad0;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 0.05em;
    user-select: none;
  }
  .btn:hover { border-color: rgba(120, 124, 150, 0.7); background: rgba(34, 34, 58, 0.9); }
  .btn.active { border-color: #ff6a3a; color: #ff6a3a; }

  .slider-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .slider-group label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    color: #6a6d78;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    white-space: nowrap;
  }
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    border-radius: 2px;
    background: rgba(50, 54, 70, 0.6);
    outline: none;
    cursor: pointer;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #c8cad0;
    border: 2px solid #0a0a1a;
    cursor: pointer;
    transition: background 0.2s;
  }
  input[type="range"]::-webkit-slider-thumb:hover { background: #ff6a3a; }
  #posSlider { width: 300px; }
  #speedSlider { width: 100px; }

  .speed-val {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    color: #8a8d98;
    min-width: 28px;
  }

  /* Equation display */
  .equation-bar {
    text-align: center;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.68rem;
    color: #5a5d68;
    padding: 8px 0 4px 0;
    letter-spacing: 0.02em;
    line-height: 1.6;
  }
  .equation-bar .eq-highlight { color: #38bdf8; }
  .equation-bar .eq-dim { color: #3a3d48; }

  /* Starfield background */
  #starfield {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    pointer-events: none;
  }
</style>
</head>
<body>

<canvas id="starfield"></canvas>
<div id="horizon-flash"></div>
<div id="floor-flash"></div>

<div class="container">
  <h1><span class="dim">///</span> Benford's Law <span class="accent">Through a Black Hole</span> <span class="dim">///</span></h1>
  <div class="subtitle">Causal Set Quantum Gravity &mdash; Digit Distribution vs. Radial Position (r/r<sub>s</sub>)</div>

  <!-- HUD -->
  <div class="hud-row">
    <div class="hud-card" id="hudR">
      <div class="hud-label">r / r<sub>s</sub></div>
      <div class="hud-value" id="valR">10.000</div>
    </div>
    <div class="hud-card" id="hudZone">
      <div class="hud-label">Zone</div>
      <div class="hud-value zone-outside" id="valZone">OUTSIDE</div>
    </div>
    <div class="hud-card" id="hudDelta">
      <div class="hud-label">&delta;<sub>B</sub></div>
      <div class="hud-value" id="valDelta">0.02755</div>
      <div class="delta-meter"><div class="delta-meter-fill" id="deltaFill"></div></div>
    </div>
    <div class="hud-card" id="hudGtt">
      <div class="hud-label">g<sub>tt</sub></div>
      <div class="hud-value" id="valGtt">-0.9000</div>
    </div>
    <div class="hud-card" id="hudGdelta">
      <div class="hud-label">g<sub>&delta;</sub> = log<sub>10</sub>(1+1/&delta;<sub>B</sub>)</div>
      <div class="hud-value" id="valGdelta">1.560</div>
    </div>
    <div class="hud-card" id="hudVerdict">
      <div class="hud-label">Verdict</div>
      <div class="hud-value verdict-conforms" id="valVerdict">CONFORMS</div>
    </div>
  </div>

  <!-- Main bar chart canvas -->
  <div class="canvas-wrap">
    <canvas id="barCanvas" width="1080" height="440"></canvas>
  </div>

  <!-- Controls -->
  <div class="controls-row">
    <button class="btn" id="btnPlay">&#9654; PLAY</button>
    <button class="btn" id="btnReset">&#8634; RESET</button>
    <div class="slider-group">
      <label>Position</label>
      <input type="range" id="posSlider" min="0" max="1000" value="0" step="1">
    </div>
    <div class="slider-group">
      <label>Speed</label>
      <input type="range" id="speedSlider" min="1" max="10" value="3" step="1">
      <span class="speed-val" id="speedVal">3x</span>
    </div>
  </div>

  <!-- Delta line chart -->
  <div class="canvas-wrap">
    <canvas id="deltaCanvas" width="1080" height="160"></canvas>
  </div>

  <!-- Equation -->
  <div class="equation-bar">
    <span class="eq-dim">Benford floor:</span>
    <span class="eq-highlight">|det(g)| &ge; &radic;(&Sigma; [log<sub>10</sub>(1+1/d)]&sup2;) = 0.4068</span>
    <span class="eq-dim">&nbsp;&nbsp;|&nbsp;&nbsp; Floor activates at r/r<sub>s</sub> &asymp; 0.65</span>
  </div>
</div>

<script>
// ───────────────────────────────────────────────────────────────
// DATA
// ───────────────────────────────────────────────────────────────
const BENFORD = {1:0.30103,2:0.17609,3:0.12494,4:0.09691,5:0.07918,6:0.06695,7:0.05799,8:0.05115,9:0.04576};

const csData = [
  {r:10.0,zone:"outside",delta_b:0.027552,verdict:"MARGINAL",eps:{1:-0.001627,2:0.025311,3:-0.008147,4:-0.003489,5:-0.004109,6:-0.003403,7:-0.002438,8:-0.001631,9:-0.000468}},
  {r:7.0,zone:"outside",delta_b:0.010611,verdict:"CONFORMS",eps:{1:0.008953,2:-0.003839,3:-0.00363,4:0.000301,5:-0.001393,6:-0.000781,7:-0.000796,8:0.000074,9:0.001112}},
  {r:5.0,zone:"outside",delta_b:0.004223,verdict:"CONFORMS",eps:{1:0.002984,2:-0.000808,3:-0.002241,4:0.000996,5:-0.00073,6:-0.000781,7:-0.000575,8:0.000327,9:0.000827}},
  {r:3.0,zone:"outside",delta_b:0.002856,verdict:"CONFORMS",eps:{1:-0.001153,2:-0.001344,3:-0.000504,4:0.001944,5:0.000407,6:-0.000087,7:-0.000354,8:0.000327,9:0.000764}},
  {r:2.0,zone:"outside",delta_b:0.002748,verdict:"CONFORMS",eps:{1:0.000615,2:-0.000397,3:-0.001104,4:0.002038,5:-0.000509,6:-0.000118,7:-0.001017,8:-0.000084,9:0.000575}},
  {r:1.5,zone:"outside",delta_b:0.005169,verdict:"CONFORMS",eps:{1:-0.001627,2:-0.000397,3:0.000381,4:0.004565,5:-0.001267,6:-0.000908,7:-0.000385,8:-0.000558,9:0.000196}},
  {r:1.3,zone:"outside",delta_b:0.003184,verdict:"CONFORMS",eps:{1:-0.002044,2:-0.001243,3:-0.000127,4:0.001446,5:0.000251,6:0.001124,7:0.000954,8:-0.00023,9:-0.000131}},
  {r:1.2,zone:"outside",delta_b:0.003569,verdict:"CONFORMS",eps:{1:-0.002488,2:-0.001118,3:-0.000704,4:0.00071,5:0.000144,6:0.000085,7:0.000748,8:0.000948,9:0.001676}},
  {r:1.15,zone:"outside",delta_b:0.002757,verdict:"CONFORMS",eps:{1:-0.001084,2:-0.001395,3:-0.000648,4:0.000796,5:-0.000018,6:-0.000173,7:0.000146,8:0.000663,9:0.001713}},
  {r:1.1,zone:"outside",delta_b:0.002136,verdict:"CONFORMS",eps:{1:0.00083,2:-0.001597,3:-0.00065,4:0.000284,5:0.000234,6:-0.000227,7:-0.000038,8:0.000453,9:0.000711}},
  {r:1.08,zone:"outside",delta_b:0.00255,verdict:"CONFORMS",eps:{1:0.001578,2:-0.001689,3:-0.000649,4:0.000488,5:-0.000327,6:0.000079,7:-0.000266,8:0.000347,9:0.00044}},
  {r:1.06,zone:"outside",delta_b:0.002722,verdict:"CONFORMS",eps:{1:0.001827,2:-0.001335,3:-0.001197,4:0.000545,5:-0.000157,6:-0.000085,7:-0.000305,8:0.00005,9:0.000656}},
  {r:1.04,zone:"outside",delta_b:0.003532,verdict:"CONFORMS",eps:{1:0.002402,2:-0.001902,3:-0.001127,4:0.000728,5:-0.00066,6:0.000018,7:-0.000373,8:0.000076,9:0.000839}},
  {r:1.03,zone:"outside",delta_b:0.003889,verdict:"CONFORMS",eps:{1:0.00284,2:-0.002303,3:-0.000763,4:0.000513,5:-0.000273,6:-0.000674,7:-0.000063,8:0.000128,9:0.000597}},
  {r:1.02,zone:"outside",delta_b:0.003482,verdict:"CONFORMS",eps:{1:0.00258,2:-0.001651,3:-0.001145,4:0.000402,5:-0.000657,6:-0.000122,7:-0.0001,8:-0.000191,9:0.000883}},
  {r:1.015,zone:"outside",delta_b:0.003757,verdict:"CONFORMS",eps:{1:0.00277,2:-0.001759,3:-0.001411,4:0.00073,5:-0.000517,6:-0.000426,7:-0.00017,8:0.000256,9:0.000527}},
  {r:1.01,zone:"outside",delta_b:0.004013,verdict:"CONFORMS",eps:{1:0.003109,2:-0.001844,3:-0.001312,4:0.000529,5:-0.000407,6:-0.000782,7:0.00002,8:0.000227,9:0.000459}},
  {r:1.005,zone:"outside",delta_b:0.0042,verdict:"CONFORMS",eps:{1:0.003428,2:-0.001846,3:-0.001184,4:0.000384,5:-0.000844,6:-0.000245,7:-0.000076,8:-0.000009,9:0.000393}},
  {r:1.002,zone:"outside",delta_b:0.004049,verdict:"CONFORMS",eps:{1:0.003291,2:-0.002067,3:-0.00083,4:0.000049,5:-0.000471,6:-0.000063,7:-0.000245,8:-0.000194,9:0.000529}},
  {r:1.001,zone:"outside",delta_b:0.004166,verdict:"CONFORMS",eps:{1:0.003401,2:-0.002023,3:-0.0011,4:0.000261,5:-0.000223,6:-0.000487,7:0.000066,8:-0.000193,9:0.000298}},
  {r:0.99,zone:"inside",delta_b:0.004267,verdict:"CONFORMS",eps:{1:0.003469,2:-0.001814,3:-0.001204,4:0.000361,5:-0.000877,6:0.000097,7:-0.000574,8:0.000116,9:0.000426}},
  {r:0.95,zone:"inside",delta_b:0.005472,verdict:"CONFORMS",eps:{1:0.004771,2:-0.002154,3:-0.001312,4:0.000151,5:-0.000729,6:-0.000468,7:0.000046,8:-0.000156,9:-0.00015}},
  {r:0.9,zone:"inside",delta_b:0.00286,verdict:"CONFORMS",eps:{1:0.001586,2:0.001571,3:-0.001473,4:0.000003,5:-0.000664,6:-0.000479,7:-0.000573,8:-0.000106,9:0.000134}},
  {r:0.85,zone:"inside",delta_b:0.004293,verdict:"CONFORMS",eps:{1:0.000412,2:0.003768,3:-0.001614,4:-0.000461,5:-0.000464,6:-0.000713,7:-0.000708,8:-0.000135,9:-0.000085}},
  {r:0.8,zone:"inside",delta_b:0.003671,verdict:"CONFORMS",eps:{1:-0.000673,2:0.003112,3:0.000772,4:-0.000389,5:-0.001081,6:-0.000631,7:-0.000674,8:-0.000708,9:0.000272}},
  {r:0.7,zone:"inside",delta_b:0.006253,verdict:"CONFORMS",eps:{1:-0.002478,2:0.000009,3:0.001685,4:0.005043,5:-0.001403,6:-0.001143,7:-0.000735,8:-0.000932,9:-0.000046}},
  {r:0.6,zone:"inside",delta_b:0.006376,verdict:"CONFORMS",eps:{1:-0.004485,2:-0.001593,3:-0.000193,4:0.001492,5:0.001039,6:0.002844,7:0.002319,8:-0.001013,9:-0.00041}},
  {r:0.5,zone:"inside",delta_b:0.00486,verdict:"CONFORMS",eps:{1:0.002938,2:-0.003032,3:-0.001663,4:-0.00031,5:-0.000337,6:0.000032,7:0.000649,8:0.000186,9:0.001537}},
  {r:0.4,zone:"inside",delta_b:0.007448,verdict:"CONFORMS",eps:{1:0.003418,2:0.005182,3:-0.003184,4:-0.001454,5:-0.001584,6:-0.00117,7:-0.000754,8:-0.000495,9:0.000041}},
  {r:0.3,zone:"inside",delta_b:0.01313,verdict:"CONFORMS",eps:{1:-0.005753,2:-0.000365,3:0.002494,4:0.010985,5:-0.000603,6:-0.002195,7:-0.001837,8:-0.001446,9:-0.001279}},
  {r:0.25,zone:"inside",delta_b:0.016065,verdict:"CONFORMS",eps:{1:-0.009595,2:-0.003536,3:-0.000963,4:0.001145,5:0.001867,6:0.003335,7:0.011393,8:-0.002154,9:-0.001492}},
  {r:0.2,zone:"inside",delta_b:0.01205,verdict:"CONFORMS",eps:{1:0.009486,2:-0.006155,3:-0.003446,4:-0.001117,5:-0.001006,6:-0.000322,7:0.000324,8:0.000625,9:0.001612}},
  {r:0.15,zone:"inside",delta_b:0.015154,verdict:"CONFORMS",eps:{1:0.00353,2:0.012773,3:-0.005592,4:-0.002711,5:-0.00279,6:-0.001862,7:-0.001606,8:-0.001064,9:-0.000678}},
  {r:0.12,zone:"inside",delta_b:0.019625,verdict:"CONFORMS",eps:{1:-0.005098,2:0.003268,3:0.017389,4:-0.003907,5:-0.003712,6:-0.002661,7:-0.002261,8:-0.001883,9:-0.001135}},
  {r:0.1,zone:"inside",delta_b:0.016711,verdict:"CONFORMS",eps:{1:-0.009033,2:-0.001221,3:0.002242,4:0.007839,5:0.010163,6:-0.003301,7:-0.002832,8:-0.002118,9:-0.00174}},
  {r:0.08,zone:"inside",delta_b:0.017486,verdict:"CONFORMS",eps:{1:-0.012085,2:-0.00457,3:-0.001465,4:0.001115,5:0.002203,6:0.00414,7:0.010043,8:0.002797,9:-0.002178}},
  {r:0.06,zone:"inside",delta_b:0.01349,verdict:"CONFORMS",eps:{1:0.01039,2:-0.007004,3:-0.004097,4:-0.001483,5:-0.000936,6:-0.000346,7:0.000412,8:0.001291,9:0.001773}},
  {r:0.04,zone:"inside",delta_b:0.017329,verdict:"CONFORMS",eps:{1:0.003331,2:0.014904,3:-0.006041,4:-0.003436,5:-0.002981,6:-0.002305,7:-0.001703,8:-0.00111,9:-0.00066}},
  {r:0.02,zone:"inside",delta_b:0.018378,verdict:"CONFORMS",eps:{1:-0.012348,2:-0.004054,3:-0.000729,4:0.001271,5:0.003687,6:0.007073,7:0.009599,8:-0.002887,9:-0.001612}},
  {r:0.01,zone:"inside",delta_b:0.014661,verdict:"CONFORMS",eps:{1:0.012087,2:0.003639,3:-0.005675,4:-0.003821,5:-0.001699,6:-0.001719,7:-0.0013,8:-0.001,9:-0.000513}}
];

// Pre-sort data by r descending (should already be, but ensure)
csData.sort((a, b) => b.r - a.r);

// We map the animation parameter t in [0,1] to a position along the data array
const N = csData.length;

// ───────────────────────────────────────────────────────────────
// INTERPOLATION
// ───────────────────────────────────────────────────────────────
function lerp(a, b, f) { return a + (b - a) * f; }

function interpData(t) {
  // t in [0, 1] maps to index [0, N-1]
  const idx = t * (N - 1);
  const i0 = Math.floor(idx);
  const i1 = Math.min(i0 + 1, N - 1);
  const f = idx - i0;

  const d0 = csData[i0];
  const d1 = csData[i1];

  const r = lerp(d0.r, d1.r, f);
  const delta_b = lerp(d0.delta_b, d1.delta_b, f);
  const eps = {};
  for (let d = 1; d <= 9; d++) {
    eps[d] = lerp(d0.eps[d], d1.eps[d], f);
  }

  // Determine zone
  let zone, zoneLabel;
  if (r > 1.0) {
    zone = "outside"; zoneLabel = "OUTSIDE";
  } else if (r > 0.999 && r <= 1.001) {
    zone = "horizon"; zoneLabel = "EVENT HORIZON";
  } else if (r > 0.65) {
    zone = "inside"; zoneLabel = "INSIDE";
  } else {
    zone = "floor"; zoneLabel = "FLOOR ACTIVE";
  }

  // Pick verdict from nearest
  const nearest = f < 0.5 ? d0 : d1;
  const verdict = nearest.verdict;

  return { r, delta_b, eps, zone, zoneLabel, verdict };
}

// ───────────────────────────────────────────────────────────────
// STARFIELD
// ───────────────────────────────────────────────────────────────
const sfCanvas = document.getElementById('starfield');
const sfCtx = sfCanvas.getContext('2d');
let stars = [];

function initStarfield() {
  sfCanvas.width = window.innerWidth;
  sfCanvas.height = window.innerHeight;
  stars = [];
  const count = Math.floor((sfCanvas.width * sfCanvas.height) / 2800);
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random() * sfCanvas.width,
      y: Math.random() * sfCanvas.height,
      size: Math.random() * 1.5 + 0.3,
      alpha: Math.random() * 0.6 + 0.15,
      twinkleSpeed: Math.random() * 0.003 + 0.001,
      twinklePhase: Math.random() * Math.PI * 2
    });
  }
}

function drawStarfield(time, currentR) {
  sfCtx.clearRect(0, 0, sfCanvas.width, sfCanvas.height);
  // Darken as we go deeper
  const dimFactor = Math.max(0.15, Math.min(1, currentR / 5));
  for (const s of stars) {
    const twinkle = 0.5 + 0.5 * Math.sin(time * s.twinkleSpeed + s.twinklePhase);
    const a = s.alpha * twinkle * dimFactor;
    sfCtx.beginPath();
    sfCtx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    sfCtx.fillStyle = `rgba(200, 210, 230, ${a})`;
    sfCtx.fill();
  }
}

initStarfield();
window.addEventListener('resize', initStarfield);

// ───────────────────────────────────────────────────────────────
// BAR CHART RENDERING
// ───────────────────────────────────────────────────────────────
const barCanvas = document.getElementById('barCanvas');
const barCtx = barCanvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;

function setupCanvas(canvas, w, h) {
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
}

const BAR_W = 1080, BAR_H = 500;
const DELTA_W = 1080, DELTA_H = 160;

setupCanvas(barCanvas, BAR_W, BAR_H);
const deltaCanvas = document.getElementById('deltaCanvas');
const deltaCtx = deltaCanvas.getContext('2d');
setupCanvas(deltaCanvas, DELTA_W, DELTA_H);

function barColor(epsilonD, deltaB) {
  // Color based on magnitude of per-digit deviation relative to total deviation
  const absEps = Math.abs(epsilonD);
  // Normalized intensity: how much this digit deviates
  const intensity = Math.min(1, absEps / 0.015);
  // Green when low deviation, orange/red when high
  const r = Math.round(lerp(60, 255, intensity));
  const g = Math.round(lerp(220, 90, intensity * 0.8));
  const b = Math.round(lerp(120, 50, intensity));
  return `rgb(${r}, ${g}, ${b})`;
}

function barGlowColor(epsilonD) {
  const absEps = Math.abs(epsilonD);
  const intensity = Math.min(1, absEps / 0.015);
  const r = Math.round(lerp(60, 255, intensity));
  const g = Math.round(lerp(220, 90, intensity * 0.8));
  const b = Math.round(lerp(120, 50, intensity));
  return `rgba(${r}, ${g}, ${b}, 0.25)`;
}

function drawBarChart(data, time) {
  const ctx = barCtx;
  const W = BAR_W, H = BAR_H;
  ctx.clearRect(0, 0, W, H);

  // Background subtle gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad.addColorStop(0, 'rgba(10, 10, 28, 0)');
  bgGrad.addColorStop(1, 'rgba(8, 8, 22, 0.3)');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);

  const marginLeft = 40;
  const marginRight = 40;
  const marginTop = 50;
  const marginBottom = 30;
  const chartW = W - marginLeft - marginRight;
  const chartH = H - marginTop - marginBottom;

  // ===== COMPUTE 5D METRIC VALUES =====
  const rho = data.r;   // r / r_s
  const db = data.delta_b;

  // g_tt = -(1 - 1/rho)
  const gtt = -(1 - 1 / rho);
  // g_rr = 1/(1 - 1/rho)  (standard Schwarzschild, before floor modification)
  const grr_std = 1 / (1 - 1 / rho);
  // g_theta_theta = rho^2
  const gthth = rho * rho;
  // g_phi_phi = rho^2 * sin^2(theta) — at equator sin(theta)=1
  const gphph = rho * rho;
  // g_delta = log10(1 + 1/delta_b) — the CS dimension
  const gdelta = Math.log10(1 + 1 / db);

  // Spatial determinant: rho^4 * g_delta
  const detSpatial = Math.pow(rho, 4) * gdelta;
  const FLOOR_VAL = 0.4068;
  const floorActive = detSpatial < FLOOR_VAL;

  // Modified g_rr when floor is active: absorb compensation
  let grr = grr_std;
  if (floorActive && gthth > 0) {
    // det_spatial_target = FLOOR_VAL
    // det = rho^2 * rho^2 * g_delta * g_rr_mod  ... wait
    // Actually det(spatial) = g_rr * g_thth * g_phph * g_delta
    // = g_rr * rho^2 * rho^2 * g_delta = g_rr * rho^4 * g_delta
    // Floor: g_rr * rho^4 * g_delta >= FLOOR_VAL
    // g_rr_mod = FLOOR_VAL / (rho^4 * g_delta)
    grr = FLOOR_VAL / (Math.pow(rho, 4) * gdelta);
  }

  // Full determinant (5D): det = g_tt * g_rr * g_thth * g_phph * g_delta
  const det5d = gtt * grr * gthth * gphph * gdelta;

  // The 5 dimensions + det
  const dims = [
    { name: 'g\u2099\u2099',   sub: 'time',     val: gtt,    formula: '-(1-1/\u03C1)' },
    { name: 'g\u1D63\u1D63',   sub: 'radial',   val: grr,    formula: floorActive ? 'FLOOR/(\u03C1\u2074g\u1D5F)' : '1/(1-1/\u03C1)' },
    { name: 'g\u03B8\u03B8',   sub: 'theta',    val: gthth,  formula: '\u03C1\u00B2' },
    { name: 'g\u03C6\u03C6',   sub: 'phi',      val: gphph,  formula: '\u03C1\u00B2sin\u00B2\u03B8' },
    { name: 'g\u1D5F\u0302',   sub: 'CS',       val: gdelta, formula: 'log\u2081\u2080(1+1/\u03B4)' },
  ];

  // ===== DRAW 5 METRIC BARS =====
  const barCount = 5;
  const barGroupW = chartW / barCount;
  const barPad = barGroupW * 0.10;
  const barW = barGroupW - barPad * 2;

  // Use log-scale for bar height to handle wildly different magnitudes
  // Map |value| to bar height via log10(|value| + 1e-6), clamped
  const maxLogH = 2.5;  // log10(~316)
  const minLogH = -4;   // log10(~0.0001)
  const logRange = maxLogH - minLogH;

  function valToHeight(v) {
    const absV = Math.abs(v);
    const logV = absV > 1e-8 ? Math.log10(absV) : -8;
    const frac = (logV - minLogH) / logRange;
    return Math.max(0.02, Math.min(1, frac));
  }

  // Dimension colors (distinct for each)
  const dimColors = [
    { base: [100, 180, 255], label: 'Time' },      // blue (g_tt)
    { base: [255, 140, 60],  label: 'Radial' },     // orange (g_rr)
    { base: [80, 230, 160],  label: 'Theta' },      // green (g_thth)
    { base: [180, 130, 255], label: 'Phi' },         // purple (g_phph)
    { base: [255, 215, 0],   label: 'Causal Set' },  // gold (g_delta)
  ];

  // Title
  ctx.fillStyle = 'rgba(180, 185, 200, 0.6)';
  ctx.font = '13px "JetBrains Mono", monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('5D Black Hole Metric  \u2014  g\u03BC\u03BD = diag(g_tt, g_rr, g_\u03B8\u03B8, g_\u03C6\u03C6, g_\u03B4\u0302)', marginLeft + 4, 8);

  // Determinant info on right
  ctx.textAlign = 'right';
  ctx.font = '11px "JetBrains Mono", monospace';
  const detStr = det5d.toExponential(3);
  ctx.fillStyle = floorActive ? 'rgba(0, 200, 255, 0.7)' : 'rgba(120, 130, 160, 0.5)';
  ctx.fillText('det\u2085D = ' + detStr + (floorActive ? '  [FLOOR ACTIVE]' : ''), W - marginRight - 4, 8);
  ctx.fillStyle = 'rgba(100, 110, 140, 0.4)';
  ctx.fillText('det(spatial) = ' + detSpatial.toExponential(3) + '   floor = ' + FLOOR_VAL.toFixed(4), W - marginRight - 4, 24);

  for (let i = 0; i < barCount; i++) {
    const dim = dims[i];
    const dc = dimColors[i];
    const x = marginLeft + i * barGroupW + barPad;
    const heightFrac = valToHeight(dim.val);
    const barH = heightFrac * chartH;
    const yTop = marginTop + chartH - barH;
    const yBase = marginTop + chartH;

    // Determine bar intensity — brighter when value is more extreme
    const extremity = Math.min(1, Math.abs(Math.log10(Math.abs(dim.val) + 1e-10)) / 3);
    const bright = 0.6 + 0.4 * extremity;

    const r = Math.round(dc.base[0] * bright);
    const g = Math.round(dc.base[1] * bright);
    const b = Math.round(dc.base[2] * bright);

    // Special: flash floor-modified g_rr in cyan
    let barR = r, barG = g, barB = b;
    if (i === 1 && floorActive) {
      barR = 0; barG = 200; barB = 255;
    }

    // Glow
    ctx.shadowColor = `rgba(${barR}, ${barG}, ${barB}, 0.35)`;
    ctx.shadowBlur = 16;

    // Bar gradient
    const grad = ctx.createLinearGradient(0, yTop, 0, yBase);
    grad.addColorStop(0, `rgb(${barR}, ${barG}, ${barB})`);
    grad.addColorStop(0.7, `rgba(${barR}, ${barG}, ${barB}, 0.5)`);
    grad.addColorStop(1, `rgba(${Math.round(barR*0.3)}, ${Math.round(barG*0.3)}, ${Math.round(barB*0.3)}, 0.3)`);
    ctx.fillStyle = grad;

    // Rounded top bar
    const radius = 4;
    ctx.beginPath();
    ctx.moveTo(x + radius, yTop);
    ctx.lineTo(x + barW - radius, yTop);
    ctx.arcTo(x + barW, yTop, x + barW, yTop + radius, radius);
    ctx.lineTo(x + barW, yBase);
    ctx.lineTo(x, yBase);
    ctx.lineTo(x, yTop + radius);
    ctx.arcTo(x, yTop, x + radius, yTop, radius);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;

    // Highlight strip
    ctx.fillStyle = 'rgba(255, 255, 255, 0.07)';
    ctx.fillRect(x, yTop, 3, barH);

    // Right edge subtle shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.fillRect(x + barW - 3, yTop, 3, barH);

    // ===== VALUE LABEL (big, prominent) =====
    const valStr = formatMetricVal(dim.val);
    ctx.fillStyle = `rgba(${barR}, ${barG}, ${barB}, 0.95)`;
    ctx.font = 'bold 18px "JetBrains Mono", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(valStr, x + barW / 2, yTop - 6);

    // Sign indicator for negative values
    if (dim.val < 0) {
      ctx.fillStyle = 'rgba(255, 100, 80, 0.6)';
      ctx.font = '10px "JetBrains Mono", monospace';
      ctx.textBaseline = 'bottom';
      ctx.fillText('(negative)', x + barW / 2, yTop - 24);
    }

    // ===== DIMENSION NAME (below bar) =====
    ctx.fillStyle = `rgb(${barR}, ${barG}, ${barB})`;
    ctx.font = 'bold 16px "JetBrains Mono", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(dim.name, x + barW / 2, yBase + 4);

    // Sub-label
    ctx.fillStyle = '#6a6d78';
    ctx.font = '10px "JetBrains Mono", monospace';
    ctx.fillText(dc.label, x + barW / 2, yBase + 22);

    // Formula
    ctx.fillStyle = '#4a4d58';
    ctx.font = '9px "JetBrains Mono", monospace';
    // Truncate long formulas
    const fStr = dim.formula.length > 18 ? dim.formula.substring(0, 18) : dim.formula;
    // Don't show formula, it gets too cluttered
  }

  // Vertical scale reference (left side)
  ctx.fillStyle = '#3a3d48';
  ctx.font = '8px "JetBrains Mono", monospace';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  const scaleVals = [0.001, 0.01, 0.1, 1, 10, 100];
  for (const sv of scaleVals) {
    const frac = valToHeight(sv);
    const y = marginTop + chartH * (1 - frac);
    ctx.fillText(sv.toString(), marginLeft - 4, y);
    ctx.strokeStyle = 'rgba(60, 64, 80, 0.12)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + chartW, y);
    ctx.stroke();
  }
}

// Format metric value for display
function formatMetricVal(v) {
  const av = Math.abs(v);
  if (av >= 1000) return v.toExponential(2);
  if (av >= 100) return v.toFixed(1);
  if (av >= 10) return v.toFixed(2);
  if (av >= 1) return v.toFixed(3);
  if (av >= 0.01) return v.toFixed(4);
  if (av >= 0.001) return v.toFixed(5);
  return v.toExponential(2);
}

// ───────────────────────────────────────────────────────────────
// DELTA LINE CHART
// ───────────────────────────────────────────────────────────────
function drawDeltaChart(data, currentT) {
  const ctx = deltaCtx;
  const W = DELTA_W, H = DELTA_H;
  ctx.clearRect(0, 0, W, H);

  const marginLeft = 70;
  const marginRight = 30;
  const marginTop = 24;
  const marginBottom = 32;
  const chartW = W - marginLeft - marginRight;
  const chartH = H - marginTop - marginBottom;

  // We plot delta_b vs position index
  // x maps data index to chart x
  // y maps delta_b

  const maxDelta = 0.03;

  // Grid
  ctx.strokeStyle = 'rgba(60, 64, 80, 0.2)';
  ctx.lineWidth = 0.5;
  const dTicks = [0, 0.005, 0.010, 0.015, 0.020, 0.025, 0.030];
  for (const tick of dTicks) {
    const y = marginTop + chartH * (1 - tick / maxDelta);
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + chartW, y);
    ctx.stroke();
    ctx.fillStyle = '#4a4d58';
    ctx.font = '9px "JetBrains Mono", monospace';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText((tick * 1000).toFixed(0) + '\u2030', marginLeft - 6, y);
  }

  // Y label
  ctx.save();
  ctx.translate(14, marginTop + chartH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillStyle = '#5a5d68';
  ctx.font = '10px "JetBrains Mono", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('\u03B4_B (total deviation)', 0, 0);
  ctx.restore();

  // Horizon line
  // Find where r crosses 1.0
  let horizonX = null;
  for (let i = 0; i < N - 1; i++) {
    if (csData[i].r >= 1.0 && csData[i + 1].r < 1.0) {
      const f = (csData[i].r - 1.0) / (csData[i].r - csData[i + 1].r);
      horizonX = marginLeft + ((i + f) / (N - 1)) * chartW;
      break;
    }
  }
  if (horizonX !== null) {
    ctx.strokeStyle = 'rgba(255, 100, 50, 0.4)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 4]);
    ctx.beginPath();
    ctx.moveTo(horizonX, marginTop);
    ctx.lineTo(horizonX, marginTop + chartH);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255, 100, 50, 0.5)';
    ctx.font = '9px "JetBrains Mono", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('r=1 (horizon)', horizonX, marginTop - 4);
  }

  // Floor activation line (~r=0.65)
  let floorX = null;
  for (let i = 0; i < N - 1; i++) {
    if (csData[i].r >= 0.65 && csData[i + 1].r < 0.65) {
      const f = (csData[i].r - 0.65) / (csData[i].r - csData[i + 1].r);
      floorX = marginLeft + ((i + f) / (N - 1)) * chartW;
      break;
    }
  }
  if (floorX !== null) {
    ctx.strokeStyle = 'rgba(56, 189, 248, 0.4)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 4]);
    ctx.beginPath();
    ctx.moveTo(floorX, marginTop);
    ctx.lineTo(floorX, marginTop + chartH);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(56, 189, 248, 0.5)';
    ctx.font = '9px "JetBrains Mono", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('floor activates', floorX, marginTop - 4);
  }

  // Draw the line
  ctx.strokeStyle = 'rgba(120, 140, 200, 0.7)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < N; i++) {
    const x = marginLeft + (i / (N - 1)) * chartW;
    const y = marginTop + chartH * (1 - csData[i].delta_b / maxDelta);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Fill under the line
  ctx.lineTo(marginLeft + chartW, marginTop + chartH);
  ctx.lineTo(marginLeft, marginTop + chartH);
  ctx.closePath();
  ctx.fillStyle = 'rgba(80, 100, 180, 0.08)';
  ctx.fill();

  // Data points
  for (let i = 0; i < N; i++) {
    const x = marginLeft + (i / (N - 1)) * chartW;
    const y = marginTop + chartH * (1 - csData[i].delta_b / maxDelta);
    ctx.beginPath();
    ctx.arc(x, y, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(140, 160, 220, 0.5)';
    ctx.fill();
  }

  // Current position dot
  const curX = marginLeft + currentT * chartW;
  const curDelta = data.delta_b;
  const curY = marginTop + chartH * (1 - curDelta / maxDelta);

  // Glow
  ctx.beginPath();
  ctx.arc(curX, curY, 10, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 106, 58, 0.2)';
  ctx.fill();

  ctx.beginPath();
  ctx.arc(curX, curY, 5, 0, Math.PI * 2);
  ctx.fillStyle = '#ff6a3a';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255, 106, 58, 0.6)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Vertical guide from dot to axis
  ctx.strokeStyle = 'rgba(255, 106, 58, 0.15)';
  ctx.lineWidth = 1;
  ctx.setLineDash([2, 3]);
  ctx.beginPath();
  ctx.moveTo(curX, curY);
  ctx.lineTo(curX, marginTop + chartH);
  ctx.stroke();
  ctx.setLineDash([]);

  // R labels along x-axis for key positions
  const labelPositions = [0, 5, 10, 15, 20, 25, 30, 35, 39];
  ctx.fillStyle = '#4a4d58';
  ctx.font = '9px "JetBrains Mono", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for (const li of labelPositions) {
    const lx = marginLeft + (li / (N - 1)) * chartW;
    ctx.fillText('r=' + csData[li].r.toFixed(2), lx, marginTop + chartH + 6);
  }

  // X-axis label
  ctx.fillStyle = '#5a5d68';
  ctx.font = '10px "JetBrains Mono", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('Radial Position (r/r_s) \u2192 decreasing', marginLeft + chartW / 2, H - 4);

  // Chart title
  ctx.fillStyle = 'rgba(180, 185, 200, 0.5)';
  ctx.font = '11px "JetBrains Mono", monospace';
  ctx.textAlign = 'left';
  ctx.fillText('\u03B4_B vs Position  \u2014  Total Deviation from Benford', marginLeft + 4, 8);
}

// ───────────────────────────────────────────────────────────────
// HUD UPDATE
// ───────────────────────────────────────────────────────────────
const valR = document.getElementById('valR');
const valZone = document.getElementById('valZone');
const valDelta = document.getElementById('valDelta');
const valGtt = document.getElementById('valGtt');
const valGdelta = document.getElementById('valGdelta');
const valVerdict = document.getElementById('valVerdict');
const deltaFill = document.getElementById('deltaFill');
const hudZone = document.getElementById('hudZone');
const hudR = document.getElementById('hudR');

let prevZone = 'outside';
let horizonFlashed = false;
let floorFlashed = false;

function updateHUD(data) {
  valR.textContent = data.r.toFixed(3);

  // Zone
  valZone.textContent = data.zoneLabel;
  valZone.className = 'hud-value';
  hudZone.className = 'hud-card';
  if (data.zone === 'outside') {
    valZone.classList.add('zone-outside');
  } else if (data.zone === 'horizon') {
    valZone.classList.add('zone-horizon');
    hudZone.classList.add('highlight-horizon');
  } else if (data.zone === 'floor') {
    valZone.classList.add('zone-floor');
    hudZone.classList.add('highlight-floor');
  } else {
    valZone.classList.add('zone-inside');
  }

  // Flash effects
  if (data.zone !== 'outside' && prevZone === 'outside' && !horizonFlashed) {
    document.getElementById('horizon-flash').classList.add('active');
    setTimeout(() => document.getElementById('horizon-flash').classList.remove('active'), 2000);
    horizonFlashed = true;
  }
  if (data.zone === 'floor' && prevZone !== 'floor' && !floorFlashed) {
    document.getElementById('floor-flash').classList.add('active');
    setTimeout(() => document.getElementById('floor-flash').classList.remove('active'), 2500);
    floorFlashed = true;
  }
  prevZone = data.zone;

  // Delta
  valDelta.textContent = data.delta_b.toFixed(6);
  const deltaPct = Math.min(100, (data.delta_b / 0.03) * 100);
  deltaFill.style.width = deltaPct + '%';
  const dInt = deltaPct / 100;
  const dr = Math.round(lerp(60, 255, dInt));
  const dg = Math.round(lerp(200, 80, dInt));
  const db = Math.round(lerp(100, 50, dInt));
  deltaFill.style.background = `rgb(${dr}, ${dg}, ${db})`;

  // g_tt
  const gtt = -(1 - 1 / data.r);
  valGtt.textContent = gtt.toFixed(4);
  if (gtt > 0) valGtt.style.color = '#f87171';
  else valGtt.style.color = '#e8eaf0';

  // g_delta
  const gDelta = Math.log10(1 + 1 / data.delta_b);
  valGdelta.textContent = gDelta.toFixed(3);

  // Verdict
  valVerdict.textContent = data.verdict;
  valVerdict.className = 'hud-value';
  if (data.verdict === 'CONFORMS') valVerdict.classList.add('verdict-conforms');
  else valVerdict.classList.add('verdict-marginal');
}

// ───────────────────────────────────────────────────────────────
// ANIMATION CONTROLLER
// ───────────────────────────────────────────────────────────────
let animT = 0;        // [0, 1]
let playing = false;
let speed = 3;
let lastTime = null;
let animFrameId = null;

const posSlider = document.getElementById('posSlider');
const speedSlider = document.getElementById('speedSlider');
const speedVal = document.getElementById('speedVal');
const btnPlay = document.getElementById('btnPlay');
const btnReset = document.getElementById('btnReset');

function setT(t) {
  animT = Math.max(0, Math.min(1, t));
  posSlider.value = Math.round(animT * 1000);
}

function renderFrame(time) {
  if (!time) time = performance.now();

  if (playing && lastTime !== null) {
    const dt = (time - lastTime) / 1000;
    // Base speed: traverse in ~20 seconds at speed=1
    const rate = speed * (1 / 20);
    animT += rate * dt;
    if (animT >= 1) {
      animT = 1;
      playing = false;
      btnPlay.textContent = '\u25B6 PLAY';
      btnPlay.classList.remove('active');
    }
    posSlider.value = Math.round(animT * 1000);
  }
  lastTime = time;

  const data = interpData(animT);
  updateHUD(data);
  drawBarChart(data, time);
  drawDeltaChart(data, animT);
  drawStarfield(time, data.r);

  animFrameId = requestAnimationFrame(renderFrame);
}

btnPlay.addEventListener('click', () => {
  if (playing) {
    playing = false;
    btnPlay.textContent = '\u25B6 PLAY';
    btnPlay.classList.remove('active');
  } else {
    if (animT >= 0.999) {
      animT = 0;
      horizonFlashed = false;
      floorFlashed = false;
      prevZone = 'outside';
    }
    playing = true;
    lastTime = null;
    btnPlay.textContent = '\u23F8 PAUSE';
    btnPlay.classList.add('active');
  }
});

btnReset.addEventListener('click', () => {
  playing = false;
  btnPlay.textContent = '\u25B6 PLAY';
  btnPlay.classList.remove('active');
  animT = 0;
  posSlider.value = 0;
  horizonFlashed = false;
  floorFlashed = false;
  prevZone = 'outside';
  lastTime = null;
});

posSlider.addEventListener('input', () => {
  animT = parseInt(posSlider.value) / 1000;
  // Reset flash tracking if scrubbing back
  if (animT < 0.5) {
    horizonFlashed = false;
    floorFlashed = false;
  }
  if (animT > 0.5 && animT < 0.95) {
    floorFlashed = false;
  }
  prevZone = interpData(Math.max(0, animT - 0.001)).zone;
});

speedSlider.addEventListener('input', () => {
  speed = parseInt(speedSlider.value);
  speedVal.textContent = speed + 'x';
});

// Start rendering
requestAnimationFrame(renderFrame);

// Auto-play after a brief delay
setTimeout(() => {
  playing = true;
  lastTime = null;
  btnPlay.textContent = '\u23F8 PAUSE';
  btnPlay.classList.add('active');
}, 800);
</script>
</body>
</html>
